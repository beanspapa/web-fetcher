# 개발 순서

이 문서는 playwright-ghost 기반 headless 브라우저를 활용한 웹 컨텐츠 수집기 개발을 위한 단계별 가이드입니다.

**이 문서는 아래 순서대로 한 단계씩 직접 따라 하면서 진행해야 합니다.**

각 단계는 실제 명령어, 파일 생성, 코드 작성, 커밋 등 구체적인 작업 단위로 작성되어 있습니다. 반드시 한 단계씩 완료 후 다음 단계로 넘어가세요.

---

## 1. 프로젝트 초기 세팅

1. **Node.js 최신 LTS 버전 설치**
   - [Node.js 공식 사이트](https://nodejs.org/)에서 LTS 버전을 다운로드하여 설치한다.
   - 설치 후 터미널에서 `node -v`와 `npm -v`로 정상 설치 여부를 확인한다.

2. **작업 디렉터리 생성 및 이동**
   - 원하는 경로에 `web-fetcher` 폴더를 생성한다.
   - 터미널에서 `cd web-fetcher`로 이동한다.

3. **Git 저장소 초기화**
   - 터미널에서 `git init` 명령어로 Git 저장소를 초기화한다.

4. **package.json 생성**
   - 터미널에서 `npm init -y` 명령어로 기본 `package.json` 파일을 생성한다.

5. **TypeScript 및 ESM 환경 설정**
   - TypeScript와 타입 정의 패키지 설치:  
     `npm install --save-dev typescript @types/node`
   - `tsconfig.json` 파일 생성:  
     `npx tsc --init --rootDir src --outDir dist --module esnext --moduleResolution node --target es2020 --esModuleInterop true --resolveJsonModule true --strict true`
   - `package.json`에 다음 항목 추가/수정:
     - `"type": "module"`
     - `"main": "dist/main.js"`
     - `"scripts"`에   
       `"build": "tsc",`  
       `"start": "node dist/main.js"`

6. **기본 폴더 구조 생성**
   - `src` 폴더 생성: `mkdir src`
   - `test` 폴더 생성: `mkdir test`
   - `src/main.ts` 파일 생성: `echo > src/main.ts`

7. **.gitignore 파일 생성**
   - `.gitignore` 파일을 만들고 아래 내용을 추가:
     ```
     node_modules/
     dist/
     .env
     ```

8. **.editorconfig 파일 생성**
   - `.editorconfig` 파일을 만들고 아래 내용을 추가:
     ```
     root = true

     [*]
     charset = utf-8
     indent_style = space
     indent_size = 2
     end_of_line = lf
     insert_final_newline = true
     trim_trailing_whitespace = true
     ```

9. **최초 커밋**
   - 모든 파일을 스테이징: `git add .`
   - 커밋 메시지와 함께 최초 커밋: `git commit -m "프로젝트 초기 세팅 및 기본 환경 구성"`

## 2. 의존성 설치

1. **playwright-ghost, playwright-extra, playwright 설치**
   - 터미널에서 아래 명령어를 입력하여 필수 라이브러리를 설치합니다.
     ```bash
     npm install playwright-ghost playwright-extra playwright
     ```

2. **타입 정의 및 개발 도구 설치**
   - TypeScript 타입 정의와 개발 편의 도구를 설치합니다.
     ```bash
     npm install --save-dev @types/node eslint prettier nodemon
     ```
   - 각 도구의 역할:
     - `@types/node`: Node.js 타입 지원
     - `eslint`: 코드 스타일 및 문법 검사
     - `prettier`: 코드 자동 포매팅
     - `nodemon`: 코드 변경 시 자동 재시작

3. **환경변수 관리 패키지 설치 (필요한 경우)**
   - `.env` 파일을 사용할 계획이라면 아래 명령어로 dotenv를 설치합니다.
     ```bash
     npm install dotenv
     ```
   - 환경변수 사용 예시:
     - `.env` 파일 생성 후, `process.env.변수명`으로 접근

4. **설치 확인**
   - `package.json`의 `dependencies`와 `devDependencies`에 위 패키지들이 정상적으로 추가되었는지 확인합니다.
   - 터미널에서 `npm ls` 또는 `npm ls --depth=0`로 설치된 패키지 목록을 확인할 수 있습니다.

## 3. 기본 크롤러 구조 설계

1. **src/main.ts(진입점) 파일 생성**
   - `src` 폴더가 없다면 먼저 생성:  
     ```bash
     mkdir src
     ```
   - 크롤러의 진입점 파일 생성:  
     ```bash
     echo > src/main.ts
     ```

2. **크롤러 설정값 구조 설계 및 config 파일 작성**
   - 크롤링 대상 URL, 옵션 등을 관리할 설정 파일 생성:  
     ```bash
     echo > src/config.ts
     ```
   - 예시 코드(`src/config.ts`):
     ```typescript
     export const config = {
       targetUrl: 'https://example.com',
       headless: true,
       timeout: 30000
     };
     ```

3. **환경변수(.env) 파일 설계 및 예시 파일 작성**
   - 프로젝트 루트에 `.env` 파일 생성(민감 정보, 환경별 값 등 저장):
     ```
     TARGET_URL=https://example.com
     HEADLESS=true
     TIMEOUT=30000
     ```
   - `.env.example` 파일도 함께 생성하여 예시 값 제공:
     ```
     TARGET_URL=
     HEADLESS=
     TIMEOUT=
     ```

4. **크롤러 실행 흐름 설계**
   - `src/main.ts`에 아래와 같이 기본 실행 흐름을 작성:
     ```typescript
     import { config } from './config.js';

     async function main() {
       // 1. 브라우저 실행
       // 2. 페이지 이동
       // 3. 데이터 추출
       // 4. 결과 출력 또는 저장
     }

     main();
     ```
   - 각 단계별로 함수 분리 및 주석 추가

5. **설정 파일, 환경변수, 코드 연결**
   - `dotenv`를 사용하는 경우, `src/main.ts` 상단에 추가:
     ```typescript
     import 'dotenv/config';
     ```
   - 환경변수와 config 값을 연동:
     ```typescript
     const targetUrl = process.env.TARGET_URL || config.targetUrl;
     ```

6. **설계/구현 후 커밋**
   - 변경된 파일을 스테이징:  
     `git add src/main.ts src/config.ts .env .env.example`
   - 커밋 메시지와 함께 저장:  
     `git commit -m "크롤러 기본 구조 및 설정 파일 추가"`


## 4. playwright-ghost 브라우저 제어 코드 작성

1. **playwright-ghost 브라우저 인스턴스 생성 코드 작성**
   - `src/main.ts`에 아래 코드를 추가:
     ```typescript
     import { launchGhost } from 'playwright-ghost';

     async function main() {
       const browser = await launchGhost({ headless: process.env.HEADLESS !== 'false' });
       // 이후 코드 작성
     }
     ```

2. **페이지 이동 및 네트워크 대기 옵션 적용**
   - 브라우저에서 새 페이지를 열고, 타겟 URL로 이동:
     ```typescript
     const page = await browser.newPage();
     await page.goto(process.env.TARGET_URL || config.targetUrl, { waitUntil: 'networkidle' });
     ```

3. **headless 모드 동작 확인 및 디버깅 방법 정리**
   - headless 모드가 정상 동작하는지 확인:
     - `HEADLESS=false`로 실행 시 실제 브라우저 창이 뜨는지 확인
     - `console.log`로 현재 모드 출력
   - 디버깅을 위해 `slowMo` 옵션 등 추가 가능:
     ```typescript
     const browser = await launchGhost({ headless: process.env.HEADLESS !== 'false', slowMo: 100 });
     ```

4. **User-Agent, 쿠키 등 커스텀 브라우저 옵션 적용**
   - 페이지에 User-Agent 설정:
     ```typescript
     await page.setUserAgent('MyCustomUserAgent/1.0');
     ```
   - 필요시 쿠키, 헤더 등 추가 설정

5. **에러 발생 시 재시도/종료 로직 설계**
   - try-catch로 에러를 감싸고, 실패 시 브라우저 종료 및 에러 메시지 출력:
     ```typescript
     try {
       // 크롤링 코드
     } catch (error) {
       console.error('크롤링 중 에러 발생:', error);
     } finally {
       await browser.close();
     }
     ```

6. **구현 후 커밋**
   - 변경된 파일을 스테이징:  
     `git add src/main.ts`
   - 커밋 메시지와 함께 저장:  
     `git commit -m "playwright-ghost 브라우저 제어 코드 및 기본 이동 로직 구현"`


## 5. 데이터 추출 및 가공 로직 구현

1. **DOM 파싱 및 원하는 데이터 선택자(selector) 정의**
   - 크롤링할 페이지에서 추출할 데이터의 CSS 선택자를 미리 정한다.
   - 예시: 기사 제목, 본문, 이미지 등

2. **데이터 추출 코드 작성**
   - `src/main.ts`에서 페이지에서 원하는 데이터를 추출하는 코드를 작성:
     ```typescript
     const title = await page.$eval('h1', el => el.textContent?.trim() || '');
     const content = await page.$eval('.article-body', el => el.textContent?.trim() || '');
     ```
   - 여러 데이터가 있을 경우 `$$eval`을 사용하여 배열로 추출:
     ```typescript
     const links = await page.$$eval('a', els => els.map(el => el.href));
     ```

3. **여러 페이지/리스트 크롤링 시 반복 처리 구조 설계**
   - 여러 URL을 순회해야 한다면 배열로 관리하고 for문 또는 for...of로 반복 처리:
     ```typescript
     const urls = [/* URL 목록 */];
     for (const url of urls) {
       await page.goto(url, { waitUntil: 'networkidle' });
       // 데이터 추출
     }
     ```

4. **추출 데이터의 구조화 및 유효성 검사**
   - 추출한 데이터를 객체로 정리:
     ```typescript
     const result = { title, content, url: page.url() };
     ```
   - 데이터가 비어 있거나 유효하지 않은 경우 로그 출력 또는 예외 처리

5. **예외 상황(404, 비정상 응답 등) 처리 및 로깅**
   - HTTP 상태 코드 확인:
     ```typescript
     const response = await page.goto(url, { waitUntil: 'networkidle' });
     if (!response || !response.ok()) {
       console.error(`페이지 로드 실패: ${url}`);
       continue;
     }
     ```
   - try-catch로 각 데이터 추출 구문 감싸기

6. **구현 후 커밋**
   - 변경된 파일을 스테이징:  
     `git add src/main.ts`
   - 커밋 메시지와 함께 저장:  
     `git commit -m "데이터 추출 및 가공 로직 구현"`


## 6. 결과 저장 및 출력 기능 구현

1. **결과 저장 방식 결정**
   - 추출한 데이터를 파일(JSON, CSV 등)로 저장할지, 데이터베이스에 저장할지 결정한다.
   - 여기서는 파일 저장 예시를 기준으로 설명합니다.

2. **파일 저장 코드 작성**
   - Node.js의 `fs` 모듈을 사용하여 결과를 저장:
     ```typescript
     import { writeFileSync, existsSync, mkdirSync } from 'fs';

     // 결과 저장 폴더가 없으면 생성
     if (!existsSync('results')) {
       mkdirSync('results');
     }

     // 결과를 JSON 파일로 저장
     writeFileSync(`results/result.json`, JSON.stringify(result, null, 2), 'utf-8');
     ```
   - 여러 결과를 저장할 경우 배열로 모아 한 번에 저장하거나, 각 결과를 별도 파일로 저장

3. **CSV 저장이 필요한 경우**
   - `csv-writer` 등 라이브러리 설치:  
     `npm install csv-writer`
   - 사용 예시:
     ```typescript
     import { createObjectCsvWriter } from 'csv-writer';

     const csvWriter = createObjectCsvWriter({
       path: 'results/result.csv',
       header: [
         { id: 'title', title: 'Title' },
         { id: 'content', title: 'Content' },
         { id: 'url', title: 'URL' }
       ]
     });

     await csvWriter.writeRecords([result]);
     ```

4. **로그 및 결과 출력 포맷 설계**
   - 크롤링 성공/실패, 저장 경로, 데이터 개수 등을 콘솔에 출력:
     ```typescript
     console.log(`크롤링 완료: ${result.title}`);
     console.log('결과가 results/result.json 파일에 저장되었습니다.');
     ```

5. **에러/성공 로그 파일 분리 저장**
   - 에러 발생 시 별도 로그 파일에 저장:
     ```typescript
     import { appendFileSync } from 'fs';
     appendFileSync('results/error.log', `[${new Date().toISOString()}] ${error}\n`);
     ```

6. **구현 후 커밋**
   - 변경된 파일을 스테이징:  
     `git add src/main.ts results/`
   - 커밋 메시지와 함께 저장:  
     `git commit -m "결과 저장 및 출력 기능 구현"`


## 7. 테스트 코드 작성

1. **테스트 프레임워크 설치**
   - Jest를 사용한다면 아래 명령어로 설치:
     ```bash
     npm install --save-dev jest ts-jest @types/jest
     ```
   - `jest.config.js` 파일 생성:
     ```bash
     npx ts-jest config:init
     ```

2. **테스트 폴더 및 파일 생성**
   - `test` 폴더가 없다면 생성:  
     ```bash
     mkdir test
     ```
   - 예시 테스트 파일 생성:  
     ```bash
     echo > test/main.test.ts
     ```

3. **단위 테스트 코드 작성**
   - 주요 함수(예: 데이터 파싱, 결과 저장 등)에 대해 입력/출력 검증 테스트 작성:
     ```typescript
     import { parseTitle } from '../src/utils';

     test('제목 파싱 함수는 문자열을 반환해야 한다', () => {
       expect(parseTitle('<h1>테스트</h1>')).toBe('테스트');
     });
     ```

4. **통합 테스트 코드 작성**
   - 실제 크롤링 시나리오를 자동화하여 전체 동작을 검증:
     ```typescript
     import { main } from '../src/main';

     test('크롤러가 정상적으로 데이터를 추출해야 한다', async () => {
       const result = await main();
       expect(result.title).toBeDefined();
     });
     ```

5. **Mock 서버/데이터를 활용한 테스트 환경 구축**
   - 외부 사이트 의존성을 줄이기 위해 mock 데이터를 사용하거나, `nock` 등 라이브러리로 HTTP 요청을 가로채 테스트
   - 예시:
     ```bash
     npm install --save-dev nock
     ```
     ```typescript
     import nock from 'nock';
     nock('https://example.com').get('/').reply(200, '<h1>테스트</h1>');
     ```

6. **테스트 실행 및 결과 확인**
   - 터미널에서 테스트 실행:
     ```bash
     npx jest
     ```
   - 모든 테스트가 통과하는지 확인

7. **구현 후 커밋**
   - 변경된 파일을 스테이징:  
     `git add test/`
   - 커밋 메시지와 함께 저장:  
     `git commit -m "테스트 코드 작성 및 검증"`


## 8. 실행 및 배포 자동화

1. **npm script 작성**
   - `package.json`의 `scripts` 항목에 아래와 같이 추가:
     ```json
     "scripts": {
       "dev": "nodemon src/main.ts",
       "build": "tsc",
       "start": "node dist/main.js",
       "test": "jest"
     }
     ```

2. **빌드 및 실행 환경 분리**
   - 개발 환경: `npm run dev`로 개발 서버 실행
   - 배포/운영 환경: `npm run build` 후 `npm start`로 실행

3. **배포/실행 가이드 문서화**
   - README.md 또는 별도 문서에 실행 및 배포 방법을 명확히 작성

4. **CI/CD 파이프라인 설계 및 적용(선택)**
   - GitHub Actions, GitLab CI 등으로 자동 빌드/테스트/배포 파이프라인 구성
   - 예시: `.github/workflows/ci.yml` 파일 생성

5. **구현 후 커밋**
   - 변경된 파일을 스테이징:  
     `git add package.json .github/`
   - 커밋 메시지와 함께 저장:  
     `git commit -m "실행 및 배포 자동화 스크립트 및 가이드 추가"`


## 9. 문서화 및 유지보수

1. **README.md 최신화**
   - 프로젝트 목적, 설치 방법, 사용법, 예제 코드, 기여 방법, 라이선스 등 최신 정보로 업데이트
   - 주요 변경사항이 생길 때마다 README.md를 수정

2. **개발순서.md, API 문서 등 보조 문서 최신화**
   - 개발 단계별로 실제 진행한 내용, 시행착오, 개선점 등을 개발순서.md에 기록
   - 주요 함수, 모듈, API의 입력/출력/동작 예시를 별도 문서(예: docs/api.md)로 정리

3. **코드/설정 변경 시 문서 동기화**
   - 코드 구조, 설정 파일, 환경변수 등이 변경될 때마다 관련 문서(README, 개발순서, .env.example 등)도 함께 수정

4. **코드 리팩토링 및 확장성 점검**
   - 불필요한 코드, 중복 로직, 하드코딩된 값 등을 주기적으로 점검 및 리팩토링
   - 새로운 기능 추가 시 기존 코드와의 호환성, 확장성 고려

5. **이슈/PR 템플릿, 코드리뷰 가이드 등 협업 규칙 정립**
   - `.github/ISSUE_TEMPLATE/`, `.github/PULL_REQUEST_TEMPLATE.md` 등 템플릿 파일을 생성하여 협업 시 일관된 양식 사용
   - 코드리뷰 기준, 커밋 메시지 규칙, 브랜치 전략 등 팀 내 개발 규칙을 문서화

6. **정기적 점검 및 유지보수**
   - 의존성 패키지 업데이트 및 보안 점검
   - 테스트 코드, 빌드/배포 스크립트 정상 동작 여부 주기적 확인
   - 주요 기능 동작 확인 및 장애 발생 시 신속한 대응

7. **구현 후 커밋**
   - 변경된 문서 및 설정 파일을 스테이징:  
     `git add README.md 개발순서.md docs/ .github/`
   - 커밋 메시지와 함께 저장:  
     `git commit -m "문서화 및 유지보수 작업 반영"`

---

각 단계별 세부 작업을 체크하며 진행하면 안정적으로 개발할 수 있습니다.
